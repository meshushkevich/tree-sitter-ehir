; For possible null pointers
@enum Option[T] {
  Some(T)
  None
}

; Linked List
@ListNode[T] {
  value: T
  next: Option[ListNode<H>[T]]
}

; ...
fn @create_new_node[T](value: T) -> ListNode<H> {
  $entry:
    some_val = cape Option[T]::Some(value)
    next = cape Option[T]::None
    result = caps ListNode<H>(some_val, next)
    ret result
}

; Append new value to a linked list and return a new head
fn @append_node[T](head: ListNode<H>[T], value: T) -> ListNode<H> {
  $entry:
    new_head = call create_new_node(value)
    head_old_next = getfieldptr head::next
    head_new_next = getptr new_head
    store head_old_next, head_new_next
    ret new_head
}

; Entrypoint
; The program creates a pointer loop allocated on the heap
fn main() -> i32 {
  $entry:
    ;                           /--->---\
    ; Create linked list like: A         B
    ;                           \---<---/
    br capture_values

  $capture_values:
    A_val : u16 = capa 0_u16
    B_val : u16 = capa 1_u16
    br define_head

  $define_head:
    A = call create_new_node(A_val)
    B = call append_node(A, B_val)
    br make_loop

  $make_loop:
    B_next_ptr = getfieldptr B::next
    A_some = cape Option::Some(A)
    A_some_ptr = getptr A_some
    store B_next_ptr, A_ptr
    br check_sum_of_values

  $check_sum_of_values:
    sum = add A_val, B_val
    cbr sum, good_result, bad_result

  $good_result:
    zero = capa 0_i32
    ret zero

  $bad_result:
    dead = capa 0xDEADDEAD_i32
    ret dead

}
